use ::proc_macro2::TokenStream;
use ::quote::quote;
use ::serde::{ Deserialize, Serialize };

const VERSION_MANIFEST_V2: &str = include_str!("./version_manifest_v2.json");
const VERSION_VALIDATION: &str = include_str!("./version_validation.wiwimeta");

#[derive(Deserialize, Serialize)]
struct Manifest {
	latest: Latest,
	versions: Vec<Version>
}

#[derive(Deserialize, Serialize)]
struct Latest {
	release: String,
	snapshot: String
}

#[derive(Deserialize, Serialize)]
struct Version {
	id: String,
	r#type: String,
	url: String,
	time: String,
	#[serde(rename = "releaseTime")]
	release_time: String,
	sha1: String,
	#[serde(rename = "complianceLevel")]
	compliance_level: u8
}

/// the same one, copy pasted, as the one generated by the proc macro
#[derive(Deserialize, Serialize)]
pub enum PackFormat {
	Verified(u8),
	Unverified(u8),
	Unknown,
	None
}

pub(crate) fn inject_generated_mc_versions(input: TokenStream) -> TokenStream {
	match inject_generated_mc_versions_inner(input) {
		Ok(t) | Err(t) => { t }
	}
}

fn inject_generated_mc_versions_inner(_: TokenStream) -> Result<TokenStream, TokenStream> {
	let manifest = ::serde_json::from_str::<Manifest>(VERSION_MANIFEST_V2)
		.map_err(|err| {
			let message = format!("parsing manifest had an error: {err}");
			quote! {
				compile_error!(#message);
			}
		})?;
	let version_validation = ::ron::from_str::<Vec<(String, PackFormat)>>(VERSION_VALIDATION)
		.map_err(|err| {
			let message = format!("parsing version validation file had an error: {err}");
			quote! {
				compile_error!(#message);
			}
		})?;

	// validation of release/snapshot (not necessary but ueah)
	let release = manifest.versions.iter().any(|v| v.id == manifest.latest.release);
	let snapshot = manifest.versions.iter().any(|v| v.id == manifest.latest.snapshot);

	match (release, snapshot) {
		(true, true) => { Ok(()) }
		(true, false) => { Err(quote! {
			compile_error!("manifest is invalid: latest snapshot does not have corresponding entry in versions");
		}) }
		(false, true) => { Err(quote! {
			compile_error!("manifest is invalid: latest release does not have corresponding entry in versions");
		}) }
		(false, false) => { Err(quote! {
			compile_error!("manifest is invalid: both latest release and snapshot do not have corresponding entries in versions");
		}) }
	}?;

	let Manifest { latest, versions } = manifest;

	let mut versions = versions.into_iter()
		.map(|v| {
			(::chrono::DateTime::parse_from_rfc3339(&v.release_time).unwrap(), v)
		})
		.collect::<Vec<_>>();
	versions.sort_unstable_by_key(|v| std::cmp::Reverse(v.0));

	let versions = versions.into_iter()
		.map(|(_, Version { id: name, r#type, .. })| {
			let release_type = match &*r#type {
				"snapshot" => { quote! { ReleaseType::Snapshot } }
				"release" => { quote! { ReleaseType::Release } }
				"old_beta" => { quote! { ReleaseType::OldBeta } }
				"old_alpha" => { quote! { ReleaseType::OldAlpha } }
				t => { unreachable!("unexpectedly got \"{t}\" for a release type") }
			};

			let validated = version_validation.iter().find(|v| v.0 == name);
			let pack_format = if let Some((_, format)) = validated {
				match format {
					PackFormat::Verified(v) => { quote! { PackFormat::Verified(#v) } }
					PackFormat::Unverified(v) => { quote! { PackFormat::Unverified(#v) } }
					PackFormat::Unknown => { quote! { PackFormat::Unknown } }
					PackFormat::None => { quote! { PackFormat::None } }
				}
			} else {
				quote! { PackFormat::Unknown }
			};

			quote! {
				MCVersion {
					name: #name,
					release_type: #release_type,
					pack_format: #pack_format
				}
			}
		})
		.collect::<Vec<_>>();

	Ok(quote! {
		pub mod mc_versions {
			pub struct MCVersion {
				pub name: &'static str,
				pub release_type: ReleaseType,
				pub pack_format: PackFormat
			}

			pub enum ReleaseType {
				Snapshot,
				Release,
				OldBeta,
				OldAlpha
			}

			pub enum PackFormat {
				Verified(u8),
				Unverified(u8),
				Unknown,
				None
			}

			pub const MC_VERSIONS: &[MCVersion] = &[
				#( #versions ),*
			];
		}
	})
}
